Project source-tree
*******************

Below is the layout of our project (to 10 levels), followed by the
contents of each key file.

Project directory layout

   sphinx-no-pragma/

   ├── docs
   │   ├── _build
   │   ├── _static
   │   │   └── example_1.py
   │   ├── _templates
   │   ├── changelog.rst
   │   ├── code_of_conduct.rst
   │   ├── conf.py
   │   ├── conf.py.distrib
   │   ├── contributor_guidelines.rst
   │   ├── demo.rst
   │   ├── documentation.rst
   │   ├── index.rst
   │   ├── index.rst.distrib
   │   ├── llms.rst
   │   ├── make.bat
   │   ├── Makefile
   │   ├── package.rst
   │   ├── requirements.txt
   │   ├── security.rst
   │   └── sphinx_no_pragma.rst
   ├── examples
   │   └── example_1.py
   ├── scripts
   │   └── generate_project_source_tree.py


docs/_static/example_1.py
=========================

docs/_static/example_1.py

   from typing import Any, Optional


   def my_func(arg1: Optional[Any] = None) -> int:
       # This is a very long line that should normally fail, but we want it to
       # be present as is.
       my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters = (  # noqa
           1
       )
       print(
           my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters
       )  # noqa
       a = (
           arg1
           or my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters  # noqa
       )
       print(a)

       return "0"  # type: ignore


   class ThirdPartyLibrary:
       @staticmethod
       def get_dynamic_object() -> Any:
           # Returns an object whose type is not known at compile time
           return "a string"  # In reality, this could be any type


   # Usage of the third-party library
   obj = ThirdPartyLibrary.get_dynamic_object()

   # Attempt to use the object as a string, even though its type is 'Any'
   length = len(obj)  # type: ignore

   # Deliberately long line to violate PEP 8 line length rule, suppressed with # noqa
   print(
       f"The length of the object, a dynamically typed one, is just {length}"
   )  # noqa

   # --- Additional tests for ignore markers ---

   # Test noqa
   print("Test noqa")  # noqa

   # Test type checkers
   print("Test type: ignore")  # type: ignore

   # Test coverage and similar inline markers:
   print("Test no cover")  # pragma: no cover
   print("Test no branch")  # pragma: no branch

   # Formatting control markers:
   # fmt: off
   print("Test fmt skip block - unformatted text")  # fmt: skip
   # fmt: on
   print("This line should be formatted normally.")  # fmt: on

   # YAPF markers:
   print("Test yapf disable")  # yapf: disable
   print("Test yapf enable")  # yapf: enable

   # Pylint markers:
   print("Test pylint disable")  # pylint: disable=unused-variable
   print("Test pylint enable")  # pylint: enable=unused-variable

   # Flake8 marker:
   print("Test flake8 noqa")  # flake8: noqa: E501

   # IDE-specific suppression marker:
   print("Test noinspection directive")  # noinspection PyTypeChecker

   # Security allowlisting markers:
   print("Test allowlist secret")  # pragma: allowlist secret
   print("Test NOSONAR")  # pragma: NOSONAR


docs/changelog.rst
==================

docs/changelog.rst

   .. include:: ../CHANGELOG.rst


docs/code_of_conduct.rst
========================

docs/code_of_conduct.rst

   .. include:: ../CODE_OF_CONDUCT.rst


docs/conf.py
============

docs/conf.py

   # Configuration file for the Sphinx documentation builder.
   #
   # For the full list of built-in configuration values, see the documentation:
   # https://www.sphinx-doc.org/en/master/usage/configuration.html
   import os
   import sys

   sys.path.insert(0, os.path.abspath(".."))


   # -- Project information -----------------------------------------------------
   # https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

   try:
       import sphinx_no_pragma

       version = sphinx_no_pragma.__version__
       project = sphinx_no_pragma.__title__
       copyright = sphinx_no_pragma.__copyright__
       author = sphinx_no_pragma.__author__
   except ImportError:
       version = "0.1"
       project = "sphinx-no-pragma"
       copyright = "2023-2025, Artur Barseghyan <artur.barseghyan@gmail.com>"
       author = "Artur Barseghyan <artur.barseghyan@gmail.com>"

   # -- General configuration ---------------------------------------------------
   # https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

   extensions = [
       "sphinx.ext.autodoc",
       "sphinx.ext.viewcode",
       "sphinx.ext.todo",
       "sphinx_no_pragma",  # Important
   ]

   templates_path = ["_templates"]
   exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]

   language = "en"

   release = version

   # The suffix of source filenames.
   source_suffix = {
       ".rst": "restructuredtext",
   }

   pygments_style = "sphinx"

   # -- Options for HTML output -------------------------------------------------
   # https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

   html_theme = "sphinx_rtd_theme"
   html_static_path = ["_static"]
   # html_extra_path = ["examples"]

   prismjs_base = "//cdnjs.cloudflare.com/ajax/libs/prism/1.29.0"

   html_css_files = [
       f"{prismjs_base}/themes/prism.min.css",
       f"{prismjs_base}/plugins/toolbar/prism-toolbar.min.css",
       "https://cdn.jsdelivr.net/gh/barseghyanartur/jsphinx@1.3.4/src/css/sphinx_rtd_theme.css",
   ]

   html_js_files = [
       f"{prismjs_base}/prism.min.js",
       f"{prismjs_base}/plugins/autoloader/prism-autoloader.min.js",
       f"{prismjs_base}/plugins/toolbar/prism-toolbar.min.js",
       f"{prismjs_base}/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js",
       "https://cdn.jsdelivr.net/gh/barseghyanartur/jsphinx/src/js/download_adapter.js",
   ]

   # -- Options for todo extension ----------------------------------------------
   # https://www.sphinx-doc.org/en/master/usage/extensions/todo.html#configuration

   todo_include_todos = True

   # -- sphinx-no-pragma configuration ------------------------------------------
   # Override the default endings
   # ignore_comments_endings = [
   #     "# type: ignore",
   #     "# noqa",
   #     "# pragma: no cover",
   #     "# pragma: no branch",
   #     "# fmt: off",
   #     "# fmt: on",
   #     "# fmt: skip",
   #     "# yapf: disable",
   #     "# yapf: enable",
   #     "# pylint: disable",
   #     "# pylint: enable",
   #     "# flake8: noqa",
   #     "# noinspection",
   #     "# pragma: allowlist secret",
   #     "# pragma: NOSONAR",
   # ]
   # Set user defined endings
   user_ignore_comments_endings = ["# [start]"]


docs/contributor_guidelines.rst
===============================

docs/contributor_guidelines.rst

   .. include:: ../CONTRIBUTING.rst


docs/demo.rst
=============

docs/demo.rst

   Demo
   =====
   *Filename: example_1.py*

   .. container:: jsphinx-download

       .. literalinclude:: _static/example_1.py
           :language: python
           :lines: 1-

       *See the full example*
       :download:`here <_static/example_1.py>`


docs/documentation.rst
======================

docs/documentation.rst


   Project documentation
   =====================
   Contents:

   .. contents:: Table of Contents

   .. toctree::
      :maxdepth: 2

      index
      demo
      security
      contributor_guidelines
      code_of_conduct
      changelog
      package


docs/index.rst
==============

docs/index.rst

   .. include:: ../README.rst
   .. include:: documentation.rst


docs/llms.rst
=============

docs/llms.rst

   .. include:: ../README.rst

   ----

   .. include:: demo.rst

   ----

   .. include:: security.rst

   ----

   .. include:: contributor_guidelines.rst

   ----

   .. include:: changelog.rst

   ----

   .. include:: package.rst

   ----

   .. include:: source_tree.rst


docs/package.rst
================

docs/package.rst


   Package
   =======

   .. toctree::
      :maxdepth: 20

      sphinx_no_pragma

   Indices and tables
   ==================

   * :ref:`genindex`
   * :ref:`modindex`
   * :ref:`search`


docs/security.rst
=================

docs/security.rst

   .. include:: ../SECURITY.rst


docs/sphinx_no_pragma.rst
=========================

docs/sphinx_no_pragma.rst

   sphinx\_no\_pragma module
   =========================

   .. automodule:: sphinx_no_pragma
      :members:
      :undoc-members:
      :show-inheritance:


examples/example_1.py
=====================

examples/example_1.py

   from typing import Any, Optional


   def my_func(arg1: Optional[Any] = None) -> int:
       # This is a very long line that should normally fail, but we want it to
       # be present as is.
       my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters = (  # noqa
           1
       )
       print(
           my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters
       )  # noqa
       a = (
           arg1
           or my_very_very_very_long_variable_name_just_to_show_a_very_long_line_of_x_characters  # noqa
       )
       print(a)

       return "0"  # type: ignore


   class ThirdPartyLibrary:
       @staticmethod
       def get_dynamic_object() -> Any:
           # Returns an object whose type is not known at compile time
           return "a string"  # In reality, this could be any type


   # Usage of the third-party library
   obj = ThirdPartyLibrary.get_dynamic_object()

   # Attempt to use the object as a string, even though its type is 'Any'
   length = len(obj)  # type: ignore

   # Deliberately long line to violate PEP 8 line length rule, suppressed with # noqa
   print(
       f"The length of the object, a dynamically typed one, is just {length}"
   )  # noqa

   # --- Additional tests for ignore markers ---

   # Test noqa
   print("Test noqa")  # noqa

   # Test type checkers
   print("Test type: ignore")  # type: ignore

   # Test coverage and similar inline markers:
   print("Test no cover")  # pragma: no cover
   print("Test no branch")  # pragma: no branch

   # Formatting control markers:
   # fmt: off
   print("Test fmt skip block - unformatted text")  # fmt: skip
   # fmt: on
   print("This line should be formatted normally.")  # fmt: on

   # YAPF markers:
   print("Test yapf disable")  # yapf: disable
   print("Test yapf enable")  # yapf: enable

   # Pylint markers:
   print("Test pylint disable")  # pylint: disable=unused-variable
   print("Test pylint enable")  # pylint: enable=unused-variable

   # Flake8 marker:
   print("Test flake8 noqa")  # flake8: noqa: E501

   # IDE-specific suppression marker:
   print("Test noinspection directive")  # noinspection PyTypeChecker

   # Security allowlisting markers:
   print("Test allowlist secret")  # pragma: allowlist secret
   print("Test NOSONAR")  # pragma: NOSONAR


scripts/generate_project_source_tree.py
=======================================

scripts/generate_project_source_tree.py

   #!/usr/bin/env python3
   import argparse
   import fnmatch
   import os
   from pathlib import Path


   def build_tree(
       path: Path,
       max_depth: int,
       ignore_patterns: list,
       whitelist_dirs: list,
       include_all: bool,
       root: Path,
       prefix: str = "",
   ) -> str:
       """
       Recursively build an ASCII tree up to max_depth, applying whitelist and
       ignore rules.
       """
       if max_depth < 0:
           return ""
       entries = sorted(
           path.iterdir(), key=lambda p: (p.is_file(), p.name.lower())
       )
       lines = []
       for i, entry in enumerate(entries):
           rel_path = entry.relative_to(root).as_posix()
           # Skip ignored patterns
           if any(fnmatch.fnmatch(rel_path, pat) for pat in ignore_patterns):
               continue
           # Enforce whitelist if not including all
           if (
               not include_all
               and whitelist_dirs
               and not any(
                   rel_path.startswith(w.rstrip("/")) for w in whitelist_dirs
               )
           ):
               continue
           connector = "└── " if i == len(entries) - 1 else "├── "
           lines.append(f"{prefix}{connector}{entry.name}")
           # Recurse into directories
           if entry.is_dir():
               extension = "    " if i == len(entries) - 1 else "│   "
               subtree = build_tree(
                   entry,
                   max_depth - 1,
                   ignore_patterns,
                   whitelist_dirs,
                   include_all,
                   root,
                   prefix + extension,
               )
               if subtree:
                   lines += subtree.splitlines()
       return "\n".join(lines)


   def detect_language(path: Path) -> str:
       """Map file suffix to Sphinx language."""
       mapping = {
           ".py": "python",
           ".js": "javascript",
           ".java": "java",
           ".md": "markdown",
           ".yaml": "yaml",
           ".yml": "yaml",
           ".json": "json",
           ".sh": "bash",
           ".rst": "rst",
       }
       return mapping.get(path.suffix, "")


   def main():
       p = argparse.ArgumentParser(
           description="Auto-generate a .rst with tree + literalinclude blocks"
       )
       p.add_argument(
           "-p",
           "--project-root",
           type=Path,
           default=Path("."),
           help="Path to your project directory",
       )
       p.add_argument(
           "-d",
           "--depth",
           type=int,
           default=10,
           help="How many levels deep to print in the tree",
       )
       p.add_argument(
           "-o",
           "--output",
           type=Path,
           default=Path("docs/source_tree.rst"),
           help="Where to write the generated .rst",
       )
       p.add_argument(
           "-e",
           "--ext",
           nargs="+",
           default=[".py", ".md", ".js", ".rst"],
           help="Which file extensions to include via literalinclude",
       )
       p.add_argument(
           "-i",
           "--ignore",
           nargs="+",
           default=["__pycache__", "*.pyc", "*.py,cover"],
           help="Ignore files or dirs matching these glob patterns (relative to "
           "project root)",
       )
       p.add_argument(
           "-w",
           "--whitelist",
           nargs="+",
           default=["src", "docs", "examples", "scripts"],
           help="Directories (relative to project root) to include "
           "unless --include-all is given",
       )
       p.add_argument(
           "--include-all",
           action="store_true",
           help="Include all files regardless of whitelist",
       )
       args = p.parse_args()

       root = args.project_root.resolve()
       ignore_patterns = args.ignore
       whitelist_dirs = args.whitelist
       include_all = args.include_all
       output = args.output.resolve()
       output_dir = output.parent.resolve()

       # Header + tree
       header = f"""Project source-tree
   ===================

   Below is the layout of our project (to {args.depth} levels), followed by
   the contents of each key file.

   .. code-block:: bash
      :caption: Project directory layout

      {root.name}/
   """
       tree = build_tree(
           root,
           args.depth,
           ignore_patterns,
           whitelist_dirs,
           include_all,
           root,
           prefix="   ",
       )
       out = [header, tree, ""]

       # Walk and collect files
       for filepath in sorted(root.rglob("*")):
           if not filepath.is_file() or filepath.suffix not in args.ext:
               continue
           rel_path = filepath.relative_to(root).as_posix()
           # Skip ignored
           if any(fnmatch.fnmatch(rel_path, pat) for pat in ignore_patterns):
               continue
           # Enforce whitelist
           if (
               not include_all
               and whitelist_dirs
               and not any(
                   rel_path.startswith(w.rstrip("/")) for w in whitelist_dirs
               )
           ):
               continue

           # Compute include path relative to output_dir
           include_path = os.path.relpath(filepath, output_dir).replace(
               os.sep, "/"
           )
           title = rel_path
           underline = "-" * len(title)
           lang = detect_language(filepath)
           out += [
               title,
               underline,
               "",
               f".. literalinclude:: {include_path}",
               f"   :language: {lang}" if lang else "",
               f"   :caption: {rel_path}",
               # "   :linenos:",
               "",
           ]

       # Write output
       args.output.write_text("\n".join(line for line in out if line is not None))
       print(f"Wrote {args.output}")


   if __name__ == "__main__":
       main()
